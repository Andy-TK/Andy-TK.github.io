---
layout:     post   				    # 使用的布局（不需要改）
title:      人工智能自动规划 02：搜索算法  	# 标题 
subtitle:   墨尔本大学 COMP90054 课程笔记 #副标题
date:       2020-03-06 				# 时间
author:     Andy 						# 作者
header-img: img/post-bg-unimelb-blue.png 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - AI 自动规划
    - COMP90054
    - 课程笔记


---

<!-- 数学公式 -->
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
      inlineMath: [['$','$']]
    }
  });
</script>

# Lecture 02 搜索算法 
## 1. 基本模型算法
### 1.1 基本状态模型：经典规划
**追求的目标**：
<center><span style="color:red">写出一个能够解决所有经典搜索问题的程序。</span></center>

**状态模型 $S(P)$**：
* 有限离散状态空间 $S$
* 一个 <span style="color:blue">已知的初始状态</span> $s_0\in S$
* 一个目标状态的集合 $S_G\subseteq S$
* 每个 $s\in S$ 中可以采取的行动 $A(s)\subseteq A$
* <span style="color:blue">确定性转移函数（deterministic transition function）</span> $s'=f(a,s) \;\;\text{for}\;\; a\in A(s)$
* 正的 <span style="color:blue">行动成本（action costs）</span> $c(a,s)$

$\color{blue}{\to}$ 一个 **解** 是将 $s_0$ 映射到 $S_G$ 内部的一个可行的行动序列，如果它能够最小化 **行动成本之和**（例  
$\quad$如：移动步数），我们称其为 **最优解**。

$\color{blue}{\to}$ 通过放松 <span style="color:blue">蓝色</span> 部分的假设，我们可以得到不同的 **模型** 和 **控制器**  
$\quad$例如：假设我们的转移函数不是确定性的（deterministic），而是概率性的（probabilistic），所  
$\quad$以基于某个变量，某种情况下可能发生一种转移，而其他情况下可能发生另一种转移。我们并不  
$\quad$知道到底会发生哪种情况，这其中存在着一些概率。 

### 1.2 求解状态模型：图里面的寻路
用于规划的 **搜索算法** 利用了（经典）状态模型 $S(P)$ 与有向图之间的对应关系：
* 图中的 **结点** 代表模型中的 **状态** $s$
* 图中的 **边** $(s,s')$ 代表模型中对应的具有相同成本的 **转移**

在 **启发式搜索规划** 中，问题 $P$ 通过在与模型 $S(P)$ 关联的 **图** 上的 **路径查找** 算法得以解决。

### 1.3 搜索算法的分类
**<span style="color:red">盲目</span> 搜索 vs. <span style="color:red">启发式</span>（或者 <span style="color:red">有信息</span>）搜索**：
* <span style="color:blue">盲目搜索算法</span>：在一般搜索算法中仅使用基本的原始信息。
  * 例如：深度优先搜索（DFS）、广度优先搜索（BFS）、统一代价搜索（Uniform Cost Search, UCS，例如：Dijkstra）、迭代深化搜索（Iterative Deepening Search, IDS）
* <span style="color:blue">启发式搜索算法</span>：额外使用 <span style="color:blue">启发式函数</span> 估计到目标的距离（或剩余成本）。
  * 例如：A$^\*$ 搜索、IDA$^\*$ 搜索、爬山算法（Hill Climbing）、最佳优先搜索（Best First）、WA$^\*$ 搜索、DFS B&B 算法、LRTA$^\*$ 搜索……

**<span style="color:red">系统</span> 搜索 vs. <span style="color:red">局部</span> 搜索**：
  * <span style="color:blue">系统搜索算法</span>：同时考虑大量搜索结点。
  * <span style="color:blue">局部搜索算法</span>：一次处理一个（或几个）候选解（搜索结点）。  
    $\to$ 这不是非黑即白的区别，可以存在混杂的情况。（例如，<span style="color:blue">enforced hill-climbing</span>）

### 1.4 是什么在规划中起作用
* **盲目搜索 vs. 启发式搜索**：
  * 对于达到最低满意度要求的规划，启发式搜索在任何情况下都大大优于盲目算法。
  * 对于最优规划，启发式搜索也更好。（但差异不太明显）

* **系统搜索 vs. 局部搜索**：
  * 对于达到最低满意度要求的规划，两者都有一些成功的案例。
  * 对于最优规划，需要系统算法。

<span style="color:red">$\to$ 在这里，我们介绍了在规划中最成功的搜索算法的子集。仅涵盖了某些盲搜索算法。（为此，请  
$\quad$参阅 Russel＆Norvig 第 3 和 4 章）</span>

### 1.5 搜索算法中的术语

|术语|定义|
|:--:|--|
|<span style="color:blue">搜索结点 $n$</span>|包含搜索所到达的 *状态*，以及有关如何到达该状态的信息。|
|<span style="color:blue">路径成本 $g(n)$</span>|到达 $n$ 的路径成本。|
|<span style="color:blue">最优成本 $g^\*$</span>|一个最优解路径的成本。对于一个状态 $s$，$g^\*(s)$ 是到达 $s$ 的最便宜路径的成本。|
|<span style="color:blue">结点扩展</span>|生成一个结点的所有后继结点，通过应用适用于该结点状态的所有行动来实现。<br>在此之后，_状态_ $s$ 本身也被称为扩展过的（expanded）。|
|<span style="color:blue">搜索策略</span>|决定下一次扩展哪个结点的方法。|
|<span style="color:blue">Open List</span>|当前所有的候选扩展结点的集合。又称 <span style="color:blue">frontier（边界）</span>。|
|<span style="color:blue">Closed List</span>|所有已经扩展过的 _状态_ 的集合。仅用于 <span style="color:red">图搜索</span>，而不用于 <span style="color:red">树搜索</span>。又称 <span style="color:blue">探索<br>集（explored set）</span>|

### 1.6 世界状态 vs. 搜索状态
一个（经典）<span style="color:blue">搜索空间</span> 通过下面三种操作定义：
* <span style="color:blue">$\textrm{start}(\,)$</span>：生成初始（搜索）状态。
* <span style="color:blue">$\textrm{is-target} (s)$</span>：测试一个给定的搜索状态是否是一个目标状态。
* <span style="color:blue">$\textrm{succ} (s)$</span>：生成搜索状态 $s$ 的后继状态 $(a,s')$，其中 $a$ 是在生成该后继状态中所采取的行动。

**<span style="color:red">搜索状态 $\ne$ 世界状态</span>**：
* <span style="color:blue">前进（Progression）规划</span>  
  * 首先从问题的初始状态出发，考虑行动序列，直到找到一个能够得到目标状态的序列。
* <span style="color:blue">后退（Regression）规划</span>
  * 我们从目标状态开始，向后应用行动，直到找到一个能够达到初始状态的行动序列。

<span style="color:red">$\to$ 在整个课程中，除非另外说明，否则我们只考虑前进（Progression）规划。  
$\quad$我们用 “$s$” 交替地表示 世界状态 / 搜索状态。</span>

### 1.7 搜索状态 vs. 搜索结点
* **<span style="color:blue">搜索状态 $s$</span>**：搜索空间中的状态（顶点）
* **<span style="color:blue">搜索结点 $\sigma$</span>**：搜索状态，加上关于在搜索过程中在何处 / 何时 / 如何遇到这些状态的信息。

**一个搜索结点中包含哪些信息？**  
不同的搜索算法在一个搜索结点 $\sigma$ 中存储了不同的信息，但是一般都包含以下几种典型的信息：
* <span style="color:blue">$\textrm{state} (\sigma)$</span>：关联的搜索状态。
* <span style="color:blue">$\textrm{parent} (\sigma)$</span>：指向该搜索结点 $\sigma$ 的来源（即父结点）的指针。
* <span style="color:blue">$\textrm{action} (\sigma)$</span>：一个导致 $\textrm{state} ( \textrm{parent} (\sigma))$ 变为 $\textrm{state} (\sigma)$ 行动。
* <span style="color:blue">$g(\sigma)$</span>：$\sigma$ 的成本。（从根结点到 $\sigma$ 的路径成本）

对于根结点，$\textrm{parent} (\sigma)$ 和 $\textrm{action} (\sigma)$ 无定义。

### 1.8 搜索策略的评估指标
* **保证**
  * <span style="color:blue">完整性</span>：当一个解存在的时候，我们的策略能够保证找到这个解吗？
  * <span style="color:blue">最优性</span>：返回的解能够保证是最优解吗？

* **复杂度**
  * <span style="color:blue">时间复杂度</span>：找到一个解需要花费多长时间？（在 <span style="color:red">生成状态</span> 下进行测量）
  * <span style="color:blue">空间复杂度</span>：搜索需要占用多少内存？（在 <span style="color:red">状态</span> 下进行测量）

* **典型状态空间特征控制复杂度**
  * <span style="color:blue">分支因子 $b$</span>：每个状态有多少个继任者？
  * <span style="color:blue">目标深度 $d$</span>：到达最浅的目标状态所需行动的数量。

### 1.9 在我们开始之前
* **盲目搜索 vs. 有信息搜索**
  * <span style="color:blue">盲目搜索</span> 不需要除了问题本身以外的任何输入。
  * <span style="color:blue">有信息搜索</span> 需要额外输入一个 <span style="color:red">启发函数 $h$</span>，该函数将状态映射到它们 <span style="color:red">目标距离</span> 的估计




下节内容：搜索算法
