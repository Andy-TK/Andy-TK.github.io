I"+<h1 id="lecture-05-并发控制">Lecture 05 并发控制</h1>

<p><strong>参考教材</strong>：<em>Transaction Processing: Concepts and Techniques, Jim Gray and Andreas Reuter, Morgan Kaufmann, 1993</em></p>

<h2 id="1-并发">1. 并发</h2>

<h3 id="11-并发问题">1.1 并发问题</h3>

<p>本节课中，我们将讨论当多个事务同时访问某个共享数据资源时的一个常见问题：<strong>并发问题 (Concurrency Problems)</strong>。</p>

<p>这里，共享资源可以是一个变量、一些数据，或者一个磁盘块。</p>

<p>下面是一个相关例子，其中共享资源是一个名为 <code class="highlighter-rouge">counter</code> 的变量，其初始值为 $100$。</p>

<p><img src="http://andy-blog.oss-cn-beijing.aliyuncs.com/blog/2020-08-08-WX20200808-230358%402x.png" width="70%" /></p>

<p>第一个事务 Task1 在 <code class="highlighter-rouge">counter</code> 上加了 $10$，第二个事务 Task2 在 <code class="highlighter-rouge">counter</code> 上加了 $30$。那么，由于这些事务是并发运行的，在 Task1 和 Task2 都执行完毕后，<code class="highlighter-rouge">counter</code> 变量的最终值将是多少呢？</p>

<p>上面的 (a)、(b)、(c) 三个选项对应了三种可能的情况，具体取决于最终的 <code class="highlighter-rouge">counter</code> 值是由哪个 Task 返回的。下图给出了这三种情况对应的操作序列：</p>

<p><img src="http://andy-blog.oss-cn-beijing.aliyuncs.com/blog/2020-08-08-WX20200808-231605%402x.png" width="90%" /></p>

<p>如果不同的 Task 执行顺序将导致得到的变量 <code class="highlighter-rouge">counter</code> 的最终值不同，那么对于这种多个事务并发访问某个共享资源时存在的不确定性问题，我们需要采取某种解决方案。</p>

<p>一种保证并发事务正确执行的策略是：当 Task1 和 Task2 同时访问某个共享变量时，我们可以强制要求当其中一个事务正在对该共享资源进行更改时，另一个事务不能对该资源做出任何更改。</p>

<h3 id="12-并发控制的目的">1.2 并发控制的目的</h3>

<ul>
  <li>在相互冲突的事务之间进行强制隔离 (通过互斥)。</li>
  <li>通过保持事务执行的一致性来保持数据库的一致性。</li>
  <li>解决 “读-写” 和 “写-写” 冲突。</li>
</ul>

<h2 id="2-并发控制独占访问的实现">2. 并发控制：独占访问的实现</h2>

<p>有许多不同的方法来保证对于共享资源的独占访问：</p>

<ul>
  <li><strong>Dekker 算法</strong> (使用代码)</li>
  <li>操作系统支持的 <strong>原语 (primitives)</strong>，例如 <strong>锁 (Lock)</strong> 和 <strong>解锁 (Unlock)</strong> (通过中断调用)</li>
  <li><strong>原子机器指令 (Atomic machine instructions)</strong>，例如 <strong>test</strong>、<strong>set</strong> 或者 <strong>swap</strong> 指令 (自旋锁)，所有现代处理器都支持某种形式的 <strong>自旋锁 (Spin Locks)</strong>。</li>
</ul>

<h3 id="21-独占访问的实现dekker-算法">2.1 独占访问的实现：Dekker 算法</h3>

<p><strong>Dekker 算法</strong></p>

<p>这里我们有两个事务 T1 和 T2，然后有三个全局变量 c1、c2、turn，这些变量都可以被 T1 和 T2 访问。利用这些全局变量，我们可以检查某个事务是否对这些共享资源执行了访问。</p>

<p><img src="http://andy-blog.oss-cn-beijing.aliyuncs.com/blog/2020-08-08-WX20200808-234941%402x.png" width="90%" /></p>

<p>例如对于 T1，它试图更改某些全局变量的值，并且在成功更改之前会反复尝试。假设现在 c1 和 turn 的值被更改了，算法将检查 c2 和 turn 的值是否已经被另一个事务 T2 更改为了满足条件的值。如果满足条件，则说明在 T1 成功更改之前，另一个事务 T2 已经得到了执行访问，然后，算法将进入循环直到 T1 成功得到访问。一旦成功，T1 将使用资源，变量 <code class="highlighter-rouge">counter</code> 记录了资源使用的次数。在使用资源后，T1 将全局变量 c1 的值设置为 0，以确保另一事务 T2 能够满足成功使用共享资源的所需条件。当 T2 试图对全局变量进行更改时，算法将判断条件 {c1 == 0 or turn == 2} 是否满足，如果条件满足，说明 T1 此时没有使用共享资源，然后 T2 可以使用这些资源。同理，当 T2 使用完资源后，它将 c2 设置为 0，以确保 T1 能够满足访问资源的前提条件。</p>

<p><strong>优点</strong>：</p>

<ul>
  <li>几乎不需要硬件支持</li>
  <li>如果锁争用 (即访问锁的频率) 低，则该算法将很高效</li>
</ul>

<p><strong>缺点</strong>：</p>

<ul>
  <li>需要对主内存进行原子读写，这是一个内存访问时间周期的独占访问</li>
  <li><strong>当涉及两个以上的事务/进程时，代码的实现将非常复杂</strong></li>
  <li>对于两个以上的进程，该算法将难以理解</li>
  <li>占用大量存储空间</li>
  <li>使用繁忙等待 (即当 T2 处于运行过程中时，T1 由于不满足使用资源的前提条件而陷入长时间的循环中)</li>
</ul>

<p>为了克服 Dekker 算法的缺点，另一种策略是使用锁和解锁，具体包含两种形式：(1) 操作系统支持的原语；(2) 自旋锁。</p>

<h3 id="22-独占访问的实现操作系统支持的原语">2.2 独占访问的实现：操作系统支持的原语</h3>

<p><strong>操作系统支持的原语</strong>，例如锁和解锁：</p>

<ul>
  <li>通过中断调用，将请求传递到操作系统以实现所需的锁定请求</li>
  <li>不需要特殊的硬件</li>
</ul>

<p>•通常非常昂贵（由于保存了请求过程的上下文，因此需要执行数百至数千条指令。）</p>

<p>•不要使用繁忙的等待，因此如果锁争用较高，则更有效。</p>

<p>•解决方案与流程数量无关。</p>

<p>•与以前的方案不同，与机器无关。</p>

<p>•如果系统具有对称多处理器，则需要使用自旋锁在内核中实现OS原语</p>

<p>下节内容：并发控制</p>
:ET