I"<h1 id="lecture-05-并发控制">Lecture 05 并发控制</h1>

<p><strong>参考教材</strong>：<em>Transaction Processing: Concepts and Techniques, Jim Gray and Andreas Reuter, Morgan Kaufmann, 1993</em></p>

<h2 id="1-并发">1. 并发</h2>

<h3 id="11-并发问题">1.1 并发问题</h3>

<p>本节课中，我们将讨论当多个事务同时访问某个共享数据资源时的一个常见问题：<strong>并发问题 (Concurrency Problems)</strong>。</p>

<p>这里，共享资源可以是一个变量、一些数据，或者一个磁盘块。</p>

<p>下面是一个相关例子，其中共享资源是一个名为 <code class="highlighter-rouge">counter</code> 的变量，其初始值为 $100$。</p>

<p><img src="http://andy-blog.oss-cn-beijing.aliyuncs.com/blog/2020-08-08-WX20200808-230358%402x.png" width="70%" /></p>

<p>第一个事务 Task1 在 <code class="highlighter-rouge">counter</code> 上加了 $10$，第二个事务 Task2 在 <code class="highlighter-rouge">counter</code> 上加了 $30$。那么，由于这些事务是并发运行的，在 Task1 和 Task2 都执行完毕后，<code class="highlighter-rouge">counter</code> 变量的最终值将是多少呢？</p>

<p>上面的 (a)、(b)、(c) 三个选项对应了三种可能的情况，具体取决于最终的 <code class="highlighter-rouge">counter</code> 值是由哪个 Task 返回的。下图给出了这三种情况对应的操作序列：</p>

<p><img src="http://andy-blog.oss-cn-beijing.aliyuncs.com/blog/2020-08-08-WX20200808-231605%402x.png" width="90%" /></p>

<p>如果不同的 Task 执行顺序将导致得到的变量 <code class="highlighter-rouge">counter</code> 的最终值不同，那么对于这种多个事务并发访问某个共享资源时存在的不确定性问题，我们需要采取某种解决方案。</p>

<p>一种保证并发事务正确执行的策略是：当 Task1 和 Task2 同时访问某个共享变量时，我们可以强制要求当其中一个事务正在对该共享资源进行更改时，另一个事务不能对该资源做出任何更改。</p>

<h3 id="12-并发控制的目的">1.2 并发控制的目的</h3>

<ul>
  <li>在相互冲突的事务之间进行强制隔离 (通过互斥)。</li>
  <li>通过保持事务执行的一致性来保持数据库的一致性。</li>
  <li>解决 “读-写” 和 “写-写” 冲突。</li>
</ul>

<h2 id="2-并发控制独占访问的实现">2. 并发控制：独占访问的实现</h2>

<p>有许多不同的方法来保证</p>

<ul>
  <li>Dekker 算法 (使用代码)</li>
  <li>操作系统支持的原语 (primitives)，例如锁和解锁 (通过中断调用)</li>
</ul>

<p>•原子机器指令，例如测试和设置或交换指令 (自旋锁) -所有现代处理器都支持某种形式的自旋锁。</p>

<p>下节内容：并发控制</p>
:ET