I"/<h1 id="数据库中的机器学习哈希表b-树与学习索引">数据库中的机器学习：哈希表、B 树与学习索引</h1>

<p><strong>参考资料</strong>：</p>
<ul>
  <li><a href="https://www.youtube.com/watch?v=o1bN3gryKaw&amp;t=3087s">https://www.youtube.com/watch?v=o1bN3gryKaw&amp;t=3087s</a></li>
  <li>https://arxiv.org/abs/1712.01208</li>
</ul>

<h2 id="1-主要内容">1. 主要内容</h2>
<h3 id="11-数据库索引">1.1 数据库索引</h3>

<p>索引存在的意义：</p>

<ul>
  <li>我们有很多数据需要存储</li>
  <li>我们需要快速查询一些特定条目</li>
  <li>我们使用 <strong>索引 (Index)</strong> 完成这一任务</li>
</ul>

<p>假设我们存储了许多数据，并且希望 <strong>快速</strong> 查找其中某条或者某个特定范围的数据时，<strong>索引</strong> 可以帮助我们实现这一点。这很重要，不论是对于分析软件还是机器学习使用者，只要我们构建了一些数据 Pipeline，当我们需要快速抓取所需数据时，我们就是索引结构的 “消费者”。而 <strong>学习索引</strong> 这个新研究方向的出现使得机器学习人员也可以成为索引结构的 “生产者”。</p>

<h3 id="12-传统索引策略">1.2 传统索引策略</h3>

<p>几种常见的传统数据库索引结构及其应用场景：</p>

<ul>
  <li><strong>B 树</strong>：范围索引</li>
  <li><strong>哈希表</strong>：点索引</li>
  <li><strong>Bloom 过滤器</strong>：存在索引</li>
</ul>

<h3 id="13-新的研究方向学习索引">1.3 新的研究方向：学习索引</h3>

<p>新型 <strong>学习索引 (Learned Index)</strong> 方向：</p>

<ul>
  <li>Google 和 MIT 合作研究</li>
  <li><a href="https://arxiv.org/abs/1712.01208">https://arxiv.org/abs/1712.01208</a></li>
</ul>

<p>我们将介绍 Kraska 等人的这篇论文<a href="https://www.cl.cam.ac.uk/~ey204/teaching/ACS/R244_2018_2019/papers/Kraska_SIGMOD_2018.pdf">《The Case for Learned Index Structures》</a>，他们提出了使用 RMI 等神经网络结构代替 B 树等传统索引结构的思路，开启了数据库领域的一个新的研究方向。</p>

<h3 id="14-学习索引的优势在哪里">1.4 学习索引的优势在哪里</h3>

<p>我们将探讨他们已经完成的初步研究工作：利用机器学习方法去解决之前传统索引结构解决过的一些问题，以及他们的对标实验和权衡比较：</p>

<ul>
  <li>什么情况下，传统算法具有优势？</li>
  <li>什么情况下，学习索引具有优势？</li>
  <li>实践中如何在两者之间进行权衡？</li>
</ul>

<p>从长远看，学习索引可以更加充分利用硬件优势。随着指导预测 CPU 性能增长的摩尔定律日渐走向衰亡，目前来看，未来高性能计算将主要集中在 GPU 和并行数据指令集，机器学习方法可以很好地发挥这些优势，而传统索引结构很难做到这点。未来，随着 AI 工作负载在硬件方面的进一步深度优化，学习索引这类算法在未来将具有很大的发展潜力。</p>

<h2 id="2-什么是索引">2. 什么是索引</h2>

<p>我们先回顾一下索引：</p>

<ul>
  <li>索引可以帮助我们在海量数据中快速定位到某些特定条目。</li>
  <li>尤其是当数据并没有按照我们要查询的字段排序时会非常有用。</li>
</ul>

<p>假设我们存储了大量数据，当我们需要查询其中某些特定数据时，我们并不希望从头到尾扫描整个磁盘记录来寻找该数据，例如，当我们查询 “名字叫 Tim 的人有哪些” 或者 “某个特定日期范围内出生的人” 等，我们可以使用索引。</p>

<p>在数据库中，我们有很多行记录，每一行都存储在硬盘上，即下图中底部的块状条，其中每个格子代表一行记录：</p>

<p><img src="http://andy-blog.oss-cn-beijing.aliyuncs.com/blog/2020-08-22-WX20200822-151353%402x.png" width="80%" /></p>

<p>假设现在我们想要查询名字为 Tim 的人对应的行记录所在的位置：</p>

<p><img src="http://andy-blog.oss-cn-beijing.aliyuncs.com/blog/2020-08-22-WX20200822-152124%402x.png" width="80%" /></p>

<p>如果没有索引，整个查询过程将非常缓慢，因为我们需要依次扫描磁盘上的每一条记录。对于大公司而言，通常需要在数百万甚至数十亿条记录中搜索我们想要的结果，因此，这是一个计算成本和时间开销都非常高的过程：</p>

<p><img src="http://andy-blog.oss-cn-beijing.aliyuncs.com/blog/2020-08-22-WX20200822-152936%402x.png" width="80%" /></p>

<p>为了解决这一问题，我们构建了一种二级数据存储结构，称为索引。例如哈希表、B 树等等，我们将在后面对这些传统索引以及新型的学习索引进行讨论。假设我们构建了一个以用户名字为 Key 的索引结构，相比之前通过扫描整个表来查看数据库中的每条记录，现在我们可以直接询问索引 “嘿，名字为 Tim 的记录在哪里？”，然后索引将告诉我们名字为 Tim 的记录的内存地址的偏移量为 7。我们可以基于任何我们想要的 Key 来构建各种索引，例如用户 ID、名字、年龄等等，相比基础数据，这些索引都属于额外的二级数据结构。</p>

<p><img src="http://andy-blog.oss-cn-beijing.aliyuncs.com/blog/2020-08-22-WX20200822-154853%402x.png" width="80%" /></p>

<p>这里涉及到计算机科学研究中的一个典型的权衡问题：</p>

<ul>
  <li>索引是一种在内存用量和计算速度两者之间的权衡。</li>
  <li>索引会占用一些内存，但是可以让查询更快。</li>
</ul>

<p>我们使用一些内存来创建这样一种二级数据存储，然后通过利用一些合适的算法和数据结构来加速进程，但是代价就是会占用部分内存。而这也是学习索引中最令人感兴趣的地方：传统的索引结构通常都非常大，并且其大小还会随着输入数据量的增加而增加；然而，对于机器学习模型，尤其是神经网络模型，我们能够以一种更小的格式来获得对数据更强的表征能力，因此，对于训练好的学习索引，通常会比传统索引更小，并且同样具备快速查找记录的能力，甚至更快。</p>

<h2 id="3-索引的性能">3. 索引的性能</h2>

<p>对于索引结构，我们一般会从以下几个方面考察其性能优劣：</p>

<ul>
  <li>查询类型 (单值查询 VS. 范围查询)</li>
  <li>查找速度</li>
  <li>插入一条新记录的开销</li>
  <li>删除一条记录的开销</li>
  <li>更新一条记录的开销</li>
  <li>索引大小 &amp; 利用率</li>
</ul>

<p>我们将逐个介绍这几个方面，但是请注意，在我们要讨论的 Kraska 等人的这篇论文中，并没有显式地考虑插入、删除、更新记录的开销，该论文主要集中在只读数据集，因此并没有涉及到这些操作。所以实际上，这是目前学习索引存在局限性的一个方面，未来还需要对此进行更多研究。</p>

<p>当然，有些应用程序是专门针对只读索引的。例如 BigTable 使用只读索引并且在需要更新时会选择重构索引，以及像数据仓库这种，当涉及大量数据转储时，我们会选择在晚上访问流量较低时重构其索引。所以，目前学习索引的局限并非一种致命警告，但它仍然是一个有待进一步研究的问题。</p>

<h3 id="31-查询类型">3.1 查询类型</h3>

<p>查询类型主要可以分为两种：<strong>点到点查询</strong> 和 <strong>范围查询</strong>。</p>

<p><img src="http://andy-blog.oss-cn-beijing.aliyuncs.com/blog/2020-08-22-WX20200822-163102%402x.png" width="80%" /></p>

<p>我们可能希望利用索引查询某条或者某个范围内的特定数据，其中，对于单点查询，最常用的索引结构是哈希表；而对于范围查询，最常用的是 B 树索引。</p>

<h3 id="32-查找速度">3.2 查找速度</h3>

<p><img src="http://andy-blog.oss-cn-beijing.aliyuncs.com/blog/2020-08-22-WX20200822-170313%402x.png" width="70%" /></p>

<p>查找速度也是一个非常重要的指标：当我们询问索引时，需要等待多久才能得到结果。通常，我们用大 $O$ 记号来表示其时间复杂度。此外，有时我们也会采用一些经验测量，因为目前已经有很多相关研究，例如缓存优化以及其他一些针对计算机硬件的优化等，并且实践表明它们在改进索引性能方面都取得了一定的效果。</p>

<h3 id="33-插入--更新开销">3.3 插入 &amp; 更新开销</h3>

<p><img src="http://andy-blog.oss-cn-beijing.aliyuncs.com/blog/2020-08-22-WX20200822-191710%402x.png" width="80%" /></p>

<p>如果我们要将一条新的记录插入数据库中，我们需要更新索引，这个过程中会引入一些无法忽视的开销。同理，对某条已存在的记录进行更新时，我们同样需要更新索引结构。</p>

<h3 id="34-删除开销">3.4 删除开销</h3>

<p><img src="http://andy-blog.oss-cn-beijing.aliyuncs.com/blog/2020-08-22-WX20200822-192442%402x.png" width="80%" /></p>

<p>从原数据库中删除某条记录同样需要更新索引结构。例如，当我们询问索引 “名字叫 Tim 的人记录在哪里” 时，索引会告诉我们在红色方格所在的内存地址；而当我们将该记录删除后，索引应当告诉我们不存在相关记录。</p>

<h3 id="35-索引大小--利用率">3.5 索引大小 &amp; 利用率</h3>

<p><img src="http://andy-blog.oss-cn-beijing.aliyuncs.com/blog/2020-08-22-WX20200822-204444%402x.png" width="80%" /></p>

<p>索引会占用一些内存空间，具体大小取决于数据量，因为我们需要一种数据结构来支持我们查询索引中的每条记录或者每个 Key。利用率则是指索引中的信息密度，某些索引结构会占用远远超出其需求的大量空间，这意味着这些索引中存在许多待使用的空槽，我们将这些空槽占比称为利用率。例如，如果有一个索引结构，它实际占用的空间是其本身包含记录的两倍，那么该索引的利用率为 50%。通常，对于索引结构，尤其是哈希表，随着其利用率越来越高，其性能会逐渐下降。因此，在索引的利用率和性能之间也存在权衡问题。</p>

<h3 id="36-注意事项">3.6 注意事项</h3>

<p>然而，在我们考虑时间开销等问题时，还有一些注意事项：</p>

<ul>
  <li>索引是一种工具，主要用于 <strong>数据量很大</strong> 的情况。</li>
  <li>优化访问硬盘次数比优化总操作数更为普遍</li>
</ul>

<p>索引对于数据量很大的场景非常重要，尤其是数据多到需要使用硬盘存储时。很多索引结构实际上是在对新数据所需的硬盘访问次数进行优化，而不是在对总操作数进行优化。而这对机器学习而言是个好消息，因为我们可以将机器学习模型加载进内存，并且以一种高度并行的方式进行推断，然后告知用户应当去硬盘上的哪个地方查看指定记录，所以我们仍然可以在实现很多操作的同时最小化硬盘访问次数，甚至可能要比使用传统索引结构实现的操作数更多。并且，由于推断过程采用的是高度并行化的计算方式，学习索引还可以获得来自硬件方面的提升，例如使用 GPU 和 TPU 等，而传统索引结构则无法利用这些优势。</p>

<h2 id="4-哈希表">4. 哈希表</h2>

<p>我们已经介绍了关于索引的一些基本概念，现在我们来看一下哈希表，它也是我们前面提到的两种主要的s’y两者</p>

<h3 id="41-哈希函数将任意数据确定性地映射为一个整数">4.1 哈希函数将任意数据确定性地映射为一个整数</h3>

<p><img src="http://andy-blog.oss-cn-beijing.aliyuncs.com/blog/2020-08-22-WX20200822-212001%402x.png" width="60%" /></p>

:ET