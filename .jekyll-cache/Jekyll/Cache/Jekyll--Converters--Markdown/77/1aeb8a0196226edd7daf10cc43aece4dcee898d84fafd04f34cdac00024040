I"@3<h1 id="lecture-05-并发控制">Lecture 05 并发控制</h1>

<p><strong>参考教材</strong>：<em>Transaction Processing: Concepts and Techniques, Jim Gray and Andreas Reuter, Morgan Kaufmann, 1993</em></p>

<h2 id="1-并发">1. 并发</h2>

<h3 id="11-并发问题">1.1 并发问题</h3>

<p>本节课中，我们将讨论当多个事务同时访问某个共享数据资源时的一个常见问题：<strong>并发问题 (Concurrency Problems)</strong>。</p>

<p>这里，共享资源可以是一个变量、一些数据，或者一个磁盘块。</p>

<p>下面是一个相关例子，其中共享资源是一个名为 <code class="highlighter-rouge">counter</code> 的变量，其初始值为 $100$。</p>

<p><img src="http://andy-blog.oss-cn-beijing.aliyuncs.com/blog/2020-08-08-WX20200808-230358%402x.png" width="70%" /></p>

<p>第一个事务 Task1 在 <code class="highlighter-rouge">counter</code> 上加了 $10$，第二个事务 Task2 在 <code class="highlighter-rouge">counter</code> 上加了 $30$。那么，由于这些事务是并发运行的，在 Task1 和 Task2 都执行完毕后，<code class="highlighter-rouge">counter</code> 变量的最终值将是多少呢？</p>

<p>上面的 (a)、(b)、(c) 三个选项对应了三种可能的情况，具体取决于最终的 <code class="highlighter-rouge">counter</code> 值是由哪个 Task 返回的。下图给出了这三种情况对应的操作序列：</p>

<p><img src="http://andy-blog.oss-cn-beijing.aliyuncs.com/blog/2020-08-08-WX20200808-231605%402x.png" width="90%" /></p>

<p>如果不同的 Task 执行顺序将导致得到的变量 <code class="highlighter-rouge">counter</code> 的最终值不同，那么对于这种多个事务并发访问某个共享资源时存在的不确定性问题，我们需要采取某种解决方案。</p>

<p>一种保证并发事务正确执行的策略是：当 Task1 和 Task2 同时访问某个共享变量时，我们可以强制要求当其中一个事务正在对该共享资源进行更改时，另一个事务不能对该资源做出任何更改。</p>

<h3 id="12-并发控制的目的">1.2 并发控制的目的</h3>

<ul>
  <li>在相互冲突的事务之间进行强制隔离 (通过互斥)。</li>
  <li>通过保持事务执行的一致性来保持数据库的一致性。</li>
  <li>解决 “读-写” 和 “写-写” 冲突。</li>
</ul>

<h2 id="2-并发控制独占访问的实现">2. 并发控制：独占访问的实现</h2>

<p>有许多不同的方法来保证对于共享资源的独占访问：</p>

<ul>
  <li><strong>Dekker 算法</strong> (使用代码)</li>
  <li>操作系统支持的 <strong>原语 (primitives)</strong>，例如 <strong>锁 (Lock)</strong> 和 <strong>解锁 (Unlock)</strong> (通过中断调用)</li>
  <li><strong>原子机器指令 (Atomic machine instructions)</strong>，例如 <strong>test and set</strong> 或者 <strong>swap</strong> 指令 (自旋锁)，所有现代处理器都支持某种形式的 <strong>自旋锁 (Spin Locks)</strong>。</li>
</ul>

<h3 id="21-独占访问的实现dekker-算法">2.1 独占访问的实现：Dekker 算法</h3>

<p><strong>Dekker 算法</strong></p>

<p>这里我们有两个事务 T1 和 T2，然后有三个全局变量 <code class="highlighter-rouge">c1</code>、<code class="highlighter-rouge">c2</code>、<code class="highlighter-rouge">turn</code>，这些变量都可以被 T1 和 T2 访问。利用这些全局变量，我们可以检查某个事务是否在对这些共享资源进行独占访问。</p>

<p><img src="http://andy-blog.oss-cn-beijing.aliyuncs.com/blog/2020-08-08-WX20200808-234941%402x.png" width="90%" /></p>

<p>例如对于 T1，它试图更改某些全局变量的值，并且在成功更改之前会反复尝试。假设现在 <code class="highlighter-rouge">c1</code> 和 <code class="highlighter-rouge">turn</code> 的值被更改了，算法将检查 <code class="highlighter-rouge">c2</code> 和 <code class="highlighter-rouge">turn</code> 的值是否已经被另一个事务 T2 更改为了满足条件的值。如果满足条件，则说明在 T1 成功更改之前，另一个事务 T2 已经得到了独占访问，然后，算法将进入循环直到 T1 成功得到独占访问。一旦成功，T1 将使用资源，变量 <code class="highlighter-rouge">counter</code> 记录了资源使用的次数。在使用资源后，T1 将全局变量 <code class="highlighter-rouge">c1</code> 的值设置为 <code class="highlighter-rouge">0</code>，以确保另一事务 T2 能够满足成功使用共享资源的所需条件。当 T2 试图对全局变量进行更改时，算法将判断条件 <code class="highlighter-rouge">{c1 == 0 or turn == 2}</code> 是否满足，如果条件满足，说明 T1 此时没有使用共享资源，然后 T2 可以独占使用这些资源。同理，当 T2 使用完资源后，它将 <code class="highlighter-rouge">c2</code> 设置为 <code class="highlighter-rouge">0</code>，以确保 T1 能够满足独占访问资源的前提条件。</p>

<p><strong>优点</strong>：</p>

<ul>
  <li>几乎不需要硬件支持</li>
  <li>如果锁争用 (即访问锁的频率) 低，则该算法将很高效</li>
</ul>

<p><strong>缺点</strong>：</p>

<ul>
  <li>需要对主内存进行原子读写，这是一个内存访问时间周期的独占访问</li>
  <li><strong>当涉及两个以上的事务/进程时，代码的实现将非常复杂</strong></li>
  <li>对于两个以上的进程，该算法将难以理解</li>
  <li>占用大量存储空间</li>
  <li>使用繁忙等待 (即当 T2 处于运行过程中时，T1 由于不满足使用资源的前提条件而陷入长时间的循环中)</li>
</ul>

<p>为了克服 Dekker 算法的缺点，另一种策略是使用锁和解锁，具体包含两种形式：(1) 操作系统支持的原语；(2) 自旋锁。</p>

<h3 id="22-独占访问的实现操作系统支持的原语">2.2 独占访问的实现：操作系统支持的原语</h3>

<p><strong>操作系统支持的原语</strong>，例如锁和解锁：</p>

<p><strong>优点</strong>：</p>

<ul>
  <li>通过中断调用，将请求传递到操作系统以实现所需的锁请求</li>
  <li>不需要特殊硬件</li>
  <li>不使用繁忙等待，因此如果锁争用较高，则更高效</li>
  <li>解决方案与进程数无关</li>
  <li>与先前的方案不同，该方案与机器无关</li>
</ul>

<p><strong>缺点</strong>：</p>

<ul>
  <li>通常非常昂贵 (由于实现涉及中断调用，需要保存请求过程的上下文，因此需要执行数百至数千条指令)</li>
  <li>如果系统具有对称多处理器，则需要使用自旋锁在内核中实现 OS 原语</li>
</ul>

<h3 id="23-独占访问的实现-原子机器指令">2.3 独占访问的实现： 原子机器指令</h3>

<p><strong>原子机器指令</strong>，例如：<strong>test and set</strong> 或者 <strong>swap</strong> 指令 (自旋锁)。所有现代处理器都支持某种形式的 <strong>自旋锁</strong>。</p>

<p><strong>优点</strong>：</p>

<ul>
  <li>实现非常简单</li>
  <li>与 Dekker 算法不同，该算法不依赖进程数</li>
  <li>如果锁争用较低，则非常高效：所有数据库系统都使用它们</li>
  <li>在对称多处理器计算机中是必需的</li>
</ul>

<p><strong>缺点</strong>：</p>

<ul>
  <li>需要硬件支持–需要能够锁定总线 (CPU 和内存 + 任何其他设备之间的通信通道) 长达两个内存周期 (一个用于读取，一个用于写入)。在此期间，不允许其他设备访问此存储位置。</li>
  <li>使用繁忙等待</li>
</ul>

<h2 id="3-信号量">3. 信号量</h2>

<p>你可能听说过一个和锁机制相关的术语：<strong>信号量 (Semaphores)</strong>。它源自用于火车的相应机制：仅当信号灯熄灭时，火车才允许通过一段轨道。当火车通过轨道时，将亮起信号灯，直到火车驶离该路段为止。</p>

<p><img src="http://andy-blog.oss-cn-beijing.aliyuncs.com/blog/2020-08-08-WX20200809-005425%402x.png" width="60%" /></p>

<p><img src="http://andy-blog.oss-cn-beijing.aliyuncs.com/blog/2020-08-08-WX20200809-010015%402x.png" width="55%" /></p>

<p>计算机信号量具有一个 <code class="highlighter-rouge">get()</code> 例程，用于获取信号量 (可能等待直到其处于空闲状态)，以及一个对偶的 <code class="highlighter-rouge">give()</code> 例程，用于使该信号量返回到空闲状态 (可能通知/唤醒一个等待进程)。</p>

<p>信号量是非常简单的锁。实际上，它们被用于通用锁的实现。</p>

<h2 id="4-原子操作的实现">4. 原子操作的实现</h2>

<h3 id="41-原子操作的实现test-and-set">4.1 原子操作的实现：test and set</h3>

<p>第一种原子操作实现被称为 <strong>test and set</strong>。</p>

<p><img src="http://andy-blog.oss-cn-beijing.aliyuncs.com/blog/2020-08-08-WX20200809-010558%402x.png" width="80%" /></p>

<p>黄色方框部分以原子方式执行，内存总线将被锁定长达两个周期 (一个用于读，一个用于写)。如果变量 <code class="highlighter-rouge">lock</code> 值为 <code class="highlighter-rouge">1</code>，那么将其值重置为 <code class="highlighter-rouge">0</code>，并返回 <code class="highlighter-rouge">True</code>，这意味着独占锁 granted。</p>

<p>在 T1 中，首先通过一个 <code class="highlighter-rouge">while</code> 循环获取锁：如果 <code class="highlighter-rouge">testAndSet()</code> 返回的值为 <code class="highlighter-rouge">fasle</code>，则将继续进行循环；如果为 <code class="highlighter-rouge">true</code>，则独占锁被 granted 给 T1。如果成功得到 granted，T1 将对共享资源进行独占访问，变量 <code class="highlighter-rouge">counter</code> 记录了访问次数。访问结束后，T1 独占锁将被释放，并且将 <code class="highlighter-rouge">lock</code> 的值重置为 <code class="highlighter-rouge">1</code>，以确保其他事务 (例如 T2) 现在能够获取独占 granted。</p>

<p>那么，这个过程中，黄色方框部分的原子性是如何实现的呢？</p>

<p>假设现在 T1 要获取独占锁，现在 <code class="highlighter-rouge">lock</code> 值为 <code class="highlighter-rouge">1</code>，<code class="highlighter-rouge">if</code> 条件满足，如果在 <code class="highlighter-rouge">lock = 0</code> 语句执行后，程序崩溃，那么后续的 <code class="highlighter-rouge">return (true)</code> 将不会被执行 (并且之前的 <code class="highlighter-rouge">lock = 0</code> 更改将被清空)。这种情况下，T1 在调用 <code class="highlighter-rouge">testAndSet</code> 时不会得到任何返回值，而由于该调用发生在 <code class="highlighter-rouge">while</code> 循环中，T1 将继续对其进行调用。如果在下一次循环中，成功返回 <code class="highlighter-rouge">true</code>，那么 T1 将被 granted 独占访问权。因此，函数 <code class="highlighter-rouge">testAndSet()</code> 的中途崩溃不会对 T1 造成任何影响。通常，如果一个程序在执行中途崩溃，那么在恢复时将清空之前已执行的操作。</p>

<h3 id="42-原子操作的实现compare-and-swap">4.2 原子操作的实现：compare and swap</h3>

<p>现在，我们来看一下第二种原子操作：<strong>compare and swap</strong>。它被用于多个事务需要对某个共享变量进行更改的情况。</p>

<p>假设 <code class="highlighter-rouge">counter</code> 是一个共享变量，它可以被事务 T1、T2 访问和更改。</p>

<p><img src="http://andy-blog.oss-cn-beijing.aliyuncs.com/blog/2020-08-09-WX20200809-093046%402x.png" width="80%" /></p>

<p>如果我们按照黄色方框中的顺序进行更改，那么某些赋值或者更新操作将有可能丢失。例如，白色方框中，T2 写入 <code class="highlighter-rouge">counter == 100+30</code> 后，T1 又重新写入了 <code class="highlighter-rouge">counter == 100+10</code>，那么，之前 T2 的写入将丢失。</p>

<p>为了防止这种丢失情况发生，我们可以采用自旋锁中的 <strong>compare and swap</strong> 操作：</p>

<p><img src="http://andy-blog.oss-cn-beijing.aliyuncs.com/blog/2020-08-09-WX20200809-093848%402x.png" width="80%" /></p>

<p>函数 <code class="highlighter-rouge">cs()</code> 接受三个参数：<code class="highlighter-rouge">cell</code> 是我们希望更改的共享变量，<code class="highlighter-rouge">old</code> 是该变量先前的值，<code class="highlighter-rouge">new</code> 是更改后的值。其中的语句以原子方式执行。如果条件 <code class="highlighter-rouge">cell == old</code> 满足，说明此时其他事务还没有更改 <code class="highlighter-rouge">cell</code> 的值，那么当前事务可以进行 <code class="highlighter-rouge">cell == new</code> 更改；否则，说明 <code class="highlighter-rouge">cell</code> 的值已经被其他事务更改过，此时，我们将。</p>

<p>下节内容：并发控制</p>
:ET