I"%<!-- 数学公式 -->
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
      inlineMath: [['$','$']]
    }
  });
</script>

<h1 id="lecture-02-搜索算法">Lecture 02 搜索算法</h1>
<h2 id="1-基本模型算法">1. 基本模型算法</h2>
<h3 id="11-基本状态模型经典规划">1.1 基本状态模型：经典规划</h3>
<p><strong>追求的目标</strong>：</p>
<center><span style="color:red">写出一个能够解决所有经典搜索问题的程序。</span></center>

<p><strong>状态模型 $S(P)$</strong>：</p>
<ul>
  <li>有限离散状态空间 $S$</li>
  <li>一个 <span style="color:blue">已知的初始状态</span> $s_0\in S$</li>
  <li>一个目标状态的集合 $S_G\subseteq S$</li>
  <li>每个 $s\in S$ 中可以采取的行动 $A(s)\subseteq A$</li>
  <li><span style="color:blue">确定性转移函数（deterministic transition function）</span> $s’=f(a,s) \;\;\text{for}\;\; a\in A(s)$</li>
  <li>正的 <span style="color:blue">行动成本（action costs）</span> $c(a,s)$</li>
</ul>

<p>$\color{blue}{\to}$ 一个 <strong>解</strong> 是将 $s_0$ 映射到 $S_G$ 内部的一个可行的行动序列，如果它能够最小化 <strong>行动成本之和</strong>（例<br />
$\quad$如：移动步数），我们称其为 <strong>最优解</strong>。</p>

<p>$\color{blue}{\to}$ 通过放松 <span style="color:blue">蓝色</span> 部分的假设，我们可以得到不同的 <strong>模型</strong> 和 <strong>控制器</strong><br />
$\quad$例如：假设我们的转移函数不是确定性的（deterministic），而是概率性的（probabilistic），所<br />
$\quad$以基于某个变量，某种情况下可能发生一种转移，而其他情况下可能发生另一种转移。我们并不<br />
$\quad$知道到底会发生哪种情况，这其中存在着一些概率。</p>

<h3 id="12-求解状态模型图里面的寻路">1.2 求解状态模型：图里面的寻路</h3>
<p>用于规划的 <strong>搜索算法</strong> 利用了（经典）状态模型 $S(P)$ 与有向图之间的对应关系：</p>
<ul>
  <li>图中的 <strong>节点</strong> 代表模型中的 <strong>状态</strong> $s$</li>
  <li>图中的 <strong>边</strong> $(s,s’)$ 代表模型中对应的具有相同成本的 <strong>转移</strong></li>
</ul>

<p>在 <strong>启发式搜索规划</strong> 中，问题 $P$ 通过在与模型 $S(P)$ 关联的 <strong>图</strong> 上的 <strong>路径查找</strong> 算法得以解决。</p>

<h3 id="13-搜索算法的分类">1.3 搜索算法的分类</h3>
<p><strong><span style="color:red">盲目</span> 搜索 vs. <span style="color:red">启发式</span>（或者 <span style="color:red">有信息</span>）搜索</strong>：</p>
<ul>
  <li><span style="color:blue">盲目搜索算法</span>：在一般搜索算法中仅使用基本的原始信息。
    <ul>
      <li>例如：深度优先搜索（DFS）、广度优先搜索（BFS）、统一代价搜索（Uniform Cost Search, UCS，例如：Dijkstra）、迭代深化搜索（Iterative Deepening Search, IDS）</li>
    </ul>
  </li>
  <li><span style="color:blue">启发式搜索算法</span>：额外使用 <span style="color:blue">启发式函数</span> 估计到目标的距离（或剩余成本）。
    <ul>
      <li>例如：A$^*$ 搜索、IDA$^*$ 搜索、爬山算法（Hill Climbing）、最佳优先搜索（Best First）、WA$^*$ 搜索、DFS B&amp;B 算法、LRTA$^*$ 搜索……</li>
    </ul>
  </li>
</ul>

<p><strong><span style="color:red">系统</span> 搜索 vs. <span style="color:red">局部</span> 搜索</strong>：</p>
<ul>
  <li><span style="color:blue">系统搜索算法</span>：同时考虑大量搜索节点。</li>
  <li><span style="color:blue">局部搜索算法</span>：一次处理一个（或几个）候选解（搜索节点）。<br />
$\to$ 这不是非黑即白的区别，可以存在混杂的情况。（例如，<span style="color:blue">enforced hill-climbing</span>）</li>
</ul>

<h3 id="14-是什么在规划中起作用">1.4 是什么在规划中起作用</h3>
<ul>
  <li><strong>盲目搜索 vs. 启发式搜索</strong>：
    <ul>
      <li>对于达到最低满意度要求的规划，启发式搜索在任何情况下都大大优于盲目算法。</li>
      <li>对于最优规划，启发式搜索也更好。（但差异不太明显）</li>
    </ul>
  </li>
  <li><strong>系统搜索 vs. 局部搜索</strong>：
    <ul>
      <li>对于达到最低满意度要求的规划，两者都有一些成功的案例。</li>
      <li>对于最优规划，需要系统算法。</li>
    </ul>
  </li>
</ul>

<p><span style="color:red">$\to$ 在这里，我们介绍了在规划中最成功的搜索算法的子集。仅涵盖了某些盲搜索算法。（为此，请<br />
$\quad$参阅 Russel＆Norvig 第 3 和 4 章）</span></p>

<h3 id="15-搜索算法中的术语">1.5 搜索算法中的术语</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: center">术语</th>
      <th>定义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><span style="color:blue">搜索节点 $n$</span></td>
      <td>包含搜索所到达的 <em>状态</em>，以及有关如何到达该状态的信息。</td>
    </tr>
    <tr>
      <td style="text-align: center"><span style="color:blue">路径成本 $g(n)$</span></td>
      <td>到达 $n$ 的路径成本。</td>
    </tr>
    <tr>
      <td style="text-align: center"><span style="color:blue">最优成本 $g^*$</span></td>
      <td>一个最优解路径的成本。对于一个状态 $s$，$g^*(s)$ 是到达 $s$ 的最便宜路径的成本。</td>
    </tr>
    <tr>
      <td style="text-align: center"><span style="color:blue">节点扩展</span></td>
      <td>生成一个节点的所有后继节点，通过应用适用于该节点状态的所有行动来实现。<br />在此之后，<em>状态</em> $s$ 本身也被称为扩展过的（expanded）。</td>
    </tr>
    <tr>
      <td style="text-align: center"><span style="color:blue">搜索策略</span></td>
      <td>决定下一次扩展哪个节点的方法。</td>
    </tr>
    <tr>
      <td style="text-align: center"><span style="color:blue">Open List</span></td>
      <td>当前所有的候选扩展节点的集合。又称 <span style="color:blue">frontier（边界）</span>。</td>
    </tr>
    <tr>
      <td style="text-align: center"><span style="color:blue">Closed List</span></td>
      <td>所有已经扩展过的 <em>状态</em> 的集合。仅用于 <span style="color:red">图搜索</span>，而不用于 <span style="color:red">树搜索</span>。又称 <span style="color:blue">探索<br />集（explored set）</span></td>
    </tr>
  </tbody>
</table>

<h3 id="16-世界状态-vs-搜索状态">1.6 世界状态 vs. 搜索状态</h3>
<p>一个（经典）<span style="color:blue">搜索空间</span> 通过下面三种操作定义：</p>
<ul>
  <li><span style="color:blue">$\textrm{start()}$</span>：生成初始（搜索）状态。</li>
  <li><span style="color:blue">is-target ($s$)</span>：测试一个给定的搜索状态是否是一个目标状态。</li>
  <li><span style="color:blue">succ ($s$)</span>：生成搜索状态 $s$ 的后继状态 $(a,s’)$，其中 $a$ 是在生成该后继状态中所采取的行动。</li>
</ul>

<p><strong><span style="color:red">搜索状态 $\ne$ 世界状态</span></strong>：</p>
<ul>
  <li><span style="color:blue">前进（Progression）规划</span>
    <ul>
      <li>首先从问题的初始状态出发，考虑行动序列，直到找到一个能够得到目标状态的序列。</li>
    </ul>
  </li>
  <li><span style="color:blue">后退（Regression）规划</span>
    <ul>
      <li>我们从目标状态开始，向后应用行动，直到找到一个能够达到初始状态的行动序列。</li>
    </ul>
  </li>
</ul>

<p><span style="color:red">$\to$ 在整个课程中，除非另外说明，否则我们只考虑前进（Progression）规划。<br />
$\quad$我们用 “$s$” 交替地表示 世界状态 / 搜索状态。</span></p>

<h3 id="17-搜索状态-vs-搜索节点">1.7 搜索状态 vs. 搜索节点</h3>
<ul>
  <li><strong><span style="color:blue">搜索状态 $s$</span></strong>：搜索空间中的状态（顶点）</li>
  <li><strong><span style="color:blue">搜索节点 $\sigma$</span></strong>：搜索状态，加上关于在搜索过程中在何处 / 何时 / 如何遇到这些状态的信息。</li>
</ul>

<p><strong>一个搜索节点中包含哪些信息？</strong><br />
不同的搜索算法在一个搜索节点 $\sigma$ 中存储了不同的信息，但是一般都包含以下几种典型的信息：</p>
<ul>
  <li><span style="color:blue">state ($\sigma$)</span>：关联的搜索状态。</li>
  <li><span style="color:blue">parent ($\sigma$)</span>：指向该搜索节点 $\sigma$ 的来源（即父节点）的指针。</li>
  <li><span style="color:blue">action ($\sigma$)</span>：一个导致 state ( parent ($\sigma$) ) 变为 state ($\sigma$) 行动。</li>
  <li><span style="color:blue">$g(\sigma)$</span>：$\sigma$ 的成本。（从根节点到 $\sigma$ 的路径成本）</li>
</ul>

<p>对于根节点，parent ($\sigma$)</p>

<p>下节内容：搜索算法</p>
:ET