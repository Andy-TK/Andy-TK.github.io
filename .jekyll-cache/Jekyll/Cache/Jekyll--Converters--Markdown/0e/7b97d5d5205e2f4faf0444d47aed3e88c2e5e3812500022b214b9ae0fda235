I"!<h1 id="lecture-04-事务">Lecture 04 事务</h1>

<p><strong>参考教材</strong>：<em>Transaction Processing: Concepts and Techniques, Jim Gray and Andreas Reuter, Morgan Kaufmann, 1993</em></p>

<p>本节课中，我们将介绍 <strong>事务 (Transactions)</strong> 及其相关概念。</p>

<h2 id="1-事务模型">1. 事务模型</h2>

<h3 id="11-acid-特性">1.1 ACID 特性</h3>

<p><strong>事务 (Transactions)</strong> 是数据库系统中的一个行动或者操作单元。一个事务需要满足 <strong>ACID</strong> 特性：</p>

<ul>
  <li>
    <p><strong>原子性 (Atomicity)</strong></p>

    <p>对于数据的所有更改都当作单个操作一样执行。也就是说，要么一次性执行所有更改，要么所有更改都不执行。</p>

    <ul>
      <li>应用程序将无法直接找到失败原因。</li>
      <li>也许可以通过其他方式找到失败原因，例如：通过查看系统日志或伪造成功。</li>
    </ul>
  </li>
  <li>
    <p><strong>一致性 (Consistency)</strong></p>

    <p>当一个事务开始和结束时，数据应当处于一致状态。(例如：银行转帐)</p>

    <ul>
      <li>通常无法计算。</li>
      <li>即使可以使用某种受限语言进行计算，也可能是不切实际的，因为这意味着巨大的计算需求。</li>
      <li>只能保证受限的一致性类型，例如：后面将要讨论的可序列化交易。</li>
      <li>当原子性无法满足时将出现不一致性问题，另外，当存在并发 (同时有多个事务对同一数据进行操作) 时也可能出现不一致性问题。</li>
    </ul>
  </li>
  <li>
    <p><strong>隔离性 (Isolation)</strong></p>

    <p>事务的执行就好像它是系统上唯一的事务一样。</p>

    <ul>
      <li>例如：在某个应用程序中，将资金从一个帐户转移到另一个帐户，隔离性可以确保另一个事务只能在其中一个或另一个帐户中看到转移后的资金，但不会同时在两个帐户中看到，也不会在两个帐户中都看不到。</li>
    </ul>
  </li>
  <li>
    <p><strong>持久性 (Durability)</strong></p>

    <p>系统应该能够容忍系统故障，并且任何 <strong>已提交的更新</strong> 都不应丢失。</p>
  </li>
</ul>

<h3 id="12-磁盘更新">1.2 磁盘更新</h3>

<p><strong>磁盘写 (Disk writes) 为原子操作</strong>：</p>

<p>要么整个数据块都已正确写入磁盘，要么数据块内容未更改。为了实现原子磁盘写入，通常有两种策略：</p>

<ul>
  <li><strong>双工写 (Duplex write)</strong>
    <ul>
      <li>每个数据块都被 <strong>顺序</strong> 写入两个位置 (即第一个位置写入成功后，才会在第二个位置写入)。</li>
      <li>我们可以通过其 <strong>CRC</strong> 来确定磁盘块的错误。</li>
      <li>每个块都与一个版本号关联。具有最新版本号的块包含了最新数据。</li>
      <li>如果其中一个写入失败，则系统可以发出另一个写入。</li>
      <li>它始终保证至少一个块上具有一致的数据。</li>
    </ul>
  </li>
  <li>
    <p><strong>日志写 (Logged write)</strong></p>

    <p>与双工写类似，不同之处在于其中一个写操作会进入日志。如果对块的更改很小，则此方法将非常高效。我们将在本课程的后面讨论另一种高效方法。</p>
  </li>
</ul>

<p>下面是一个基于双工写更新磁盘块的例子，磁盘上 ID 为 123 的块上存在一些数据信息，其版本号为 v#7，我们希望对其进行一些修改：</p>

<p><img src="http://andy-blog.oss-cn-beijing.aliyuncs.com/blog/2020-08-07-WX20200807-223113%402x.png" width="60%" /></p>

<p>首先，我们将数据从磁盘上读取到主存中：</p>

<p><img src="http://andy-blog.oss-cn-beijing.aliyuncs.com/blog/2020-08-07-WX20200807-223200%402x.png" width="60%" /></p>

<p>然后，我们需要对其中某些信息进行更改，例如将 100 改为 200：</p>

<p><img src="http://andy-blog.oss-cn-beijing.aliyuncs.com/blog/2020-08-07-WX20200807-231909%402x.png" width="60%" /></p>

<p>数据已经在内存中更改完成：</p>

<p><img src="http://andy-blog.oss-cn-beijing.aliyuncs.com/blog/2020-08-07-WX20200807-223305%402x.png" width="60%" /></p>

<p>更改后的数据需要被写回磁盘中：</p>

<p><img src="http://andy-blog.oss-cn-beijing.aliyuncs.com/blog/2020-08-07-WX20200807-223401%402x.png" width="60%" /></p>

<p>但是，我们并不会立即将更改后的数据直接写入之前数据所在的块，而是先将其写入一个新的块里 (理想情况下，可以选择在另一块磁盘上写入)：</p>

<p><img src="http://andy-blog.oss-cn-beijing.aliyuncs.com/blog/2020-08-07-WX20200807-230547%402x.png" width="60%" /></p>

<p>在新的数据块 (ID 为 475) 写入完成后，它会得到一个新的版本号 v#8，由于它比原始版本号 (v#7) 要大，因此，磁盘系统会将其视为最新数据。接下来，将对原始数据块 123 中的数据进行更新，并且将其版本号升级为 v#9：</p>

<p><img src="http://andy-blog.oss-cn-beijing.aliyuncs.com/blog/2020-08-07-WX20200807-230750%402x.png" width="60%" /></p>

<p>这样做的目的是：当我们在磁盘上的数据块 123 进行第二次更改写入时，即使出现故障导致更新失败，在数据块 475 上仍然保留有正确的更新之后的数据信息。</p>

<p>我们甚至可以利用这仅有的两个块进行交叉校验：如果最新的两个版本 v#8 和 v#9 包含相同的数据信息，说明两次写入更新都是成功的，并且数据信息都是正确的。而假如其中某个失败了，导致我们只有一个数据块信息，这种情况下，我们仍然可以采用另一种被称为 <strong>循环冗余校验 (CRC)</strong> 的技术来判断该磁盘上是否存在数据错误。</p>

<h3 id="13-循环冗余校验-crc">1.3 循环冗余校验 (CRC)</h3>

<p><strong>循环冗余校验 (Cyclic Redundancy Check, CRC)</strong> 也称为 <strong>多项式编码 (polynomial code)</strong>，其基本思想是：将位串看作系数为 $0$ 或 $1$ 的多项式。</p>

<p>一个 $k$ 位的二进制串可以视为一个 $k-1$ 阶多项式的系数列表，该多项式有 $k$ 项，从 $x^{k-1}$ 到 $x^0$。对于一个 $k$ 位的二进制串，其最高 (最左边) 位对应的是 $x^{k-1}$ 项的系数，接下来的位对应的是 $x^{k-2}$ 项的系数，以此类推。</p>

<p>例如，对于一个 $6$ 位的二进制串 $110001$，其代表了一个 $5$ 阶多项式，其各项系数从左至右依次为：$1,1,0,0,0,1$，即 $1x^5+1x^4+0x^3+0x^2+0x^1+1x^0$。</p>

<p>多项式的算术运算遵守代数域理论规则，以 $2$ 为模来完成。加法没有进位，减法没有借位，加法和减法都等同于 <strong>异或 (XOR)</strong>。例如：</p>

<p><img src="http://andy-blog.oss-cn-beijing.aliyuncs.com/blog/2020-08-08-WX20200808-114748%402x.png" width="60%" /></p>

<p>长除法与二进制中的除法运算一样，只不过减法按照模 2 进行。如果被除数与除数有一样多的位，则该除数要 “进入到” 被除数中，即两者位数相同则商为 $1$，否则为 $0$。</p>

<p>使用 CRC 时，消息发送方和接收方必须先商定一个 <strong>生成多项式 (generator polynomial)</strong> $G(x)$，其最高位和最低位系数必须为 $1$。假定一个二进制消息串有 $m$ 位，对应于多项式 $M(x)$，为了计算它的 CRC，$M(x)$ 的长度必须大于 $G(x)$。基本思想是在原二进制消息串的尾部附加一个校验和，使得新的二进制串能够被 $G(x)$ 除尽。当接收方收到了带校验和的消息串后，将尝试用 $G(x)$ 去除它。如果有余数，则说明消息传输过程中发生了错误。</p>

<p>CRC 计算过程如下：</p>

<ol>
  <li>假设 $G(x)$ 的阶数为 $r$。在消息串低位端添加 $r$ 个 $0$，新的xiao’x</li>
</ol>

<p><strong>CRC 多项式 (polynomial)</strong> 例子： $x^{32}+x^{23}+x^7+1$</p>

<p>通信或磁盘上的大多数错误都是连续发生的，其本质上是突发性的。上面的 CRC 生成器可以检测所有长度小于或等于 32 位的突发错误；在长度为 33 的 100 亿个突发错误中，有 5 个不会被检测到；在长度为 34 或更大的 100 亿个突发错误中，有 3 个不会被检测到。</p>

<p>下节内容：事务</p>
:ET