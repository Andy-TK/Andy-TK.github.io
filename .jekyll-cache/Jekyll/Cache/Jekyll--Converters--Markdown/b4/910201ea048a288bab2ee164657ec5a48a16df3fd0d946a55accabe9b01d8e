I"w!<h1 id="lecture-03-容错">Lecture 03 容错</h1>

<p><strong>参考教材</strong>：<em>Transaction Processing: Concepts and Techniques, Jim Gray and Andreas Reuter, Morgan Kaufmann, 1993</em></p>

<p>这节课我们将介绍有关 <strong>容错 (Fault Tolerance)</strong> 的概念，该属性使系统在某些组件发生故障时能够继续正常运行。</p>

<h2 id="1-概率基础">1. 概率基础</h2>
<p>在正式介绍容错之前，我们将先回顾一些概率相关知识。</p>

<ul>
  <li>
    <p>$P(A)=$ 事件 $A$ 在 <strong>特定时期内</strong> 发生的概率</p>

    <p><br /></p>
  </li>
  <li>
    <p>$P(A \cap B)=$ 在这段时期内事件 $A$ 和 $B$ 都发生的概率<br />
如果 $A$ 和 $B$ 互为独立事件，那么</p>

    <script type="math/tex; mode=display">P(A \cap B)=P(A)\times P(B)</script>

    <p><br /></p>
  </li>
  <li>
    <p>$P(A \cup B)= P(A) + P(B) - P(A\cap B)$<br />
如果 $A$ 和 $B$ 互为独立事件，那么</p>

    <script type="math/tex; mode=display">% <![CDATA[
\begin{align} P(A \cup B) &= P(A)+P(B)-P(A)\times P(B) \\
&= P(A)+P(B)\qquad  (如果\, P(A)\, 和\, P(B)\, 非常小)\end{align} %]]></script>

    <p><br /></p>
  </li>
  <li>
    <p>事件发生的平均时间 $MT(A)=1/P(A)$</p>

    <p><br /></p>
  </li>
  <li>
    <p>如果事件 $A$ 和 $B$ 的平均时间分别为 $MT(A)$ 和 $MT(B)$，那么到第一次事件发生的平均时间为</p>

    <script type="math/tex; mode=display">MT(A\cup B)=\dfrac{1}{P(A\cup B)}=\dfrac{1}{P(A)+P(B)-P(A\cap B)}</script>

    <p>假设 $P(A)$ 和 $P(B)$ 都非常小，那么我们可以认为 $P(A\cap B)\approx 0$。因此，在容错问题中，我们可以认为两个系统同时发生故障的概率非常低，此时</p>

    <script type="math/tex; mode=display">MT(A\cup B)=\dfrac{1}{P(A)+P(B)}</script>
  </li>
</ul>

<h2 id="2-容错">2. 容错</h2>
<h3 id="21-模块可用性">2.1 模块可用性</h3>

<p><img src="http://andy-blog.oss-cn-beijing.aliyuncs.com/blog/2020-07-21-WX20200721-194103%402x.png" /></p>

<p>可以看到，在启动之后，系统先是正常运行，然后出现了一次故障使得系统宕机，然后经过一段时间修复，系统重新开始运行，一段时间后，系统再次由于故障宕机。</p>

<p><strong>模块可用性 (Module availability)</strong>：测量服务完成与消耗时间的比率。计算公式如下：</p>

<script type="math/tex; mode=display">\dfrac{\text{Mean time to failure}}{\text{Mean time to failure} + \text{mean time to repair}}</script>

<h3 id="22-事件发生平均时间">2.2 事件发生平均时间</h3>

<p>如果所有的 $n$ 个事件都具有相同的平均时间 $m$，那么这些事件中的某一个第一次发生的平均时间为：$m/n$。</p>

<p>推导过程：</p>

<p>如果 $p$ 是一个事件在给定时间内发生的概率，那么其平均时间为：$m=\dfrac{1}{p}$</p>

<p>如果有 $n$ 个这样的概率相同的事件，那么这些事件中有一个发生的概率为 $np$，假设 $p$ 非常小。</p>

<p>因此，这些事件中有一个发生的平均时间为：</p>

<script type="math/tex; mode=display">\dfrac{1}{np}=\dfrac{1}{p}\times \dfrac{1}{n}=\dfrac{m}{n}</script>

<h3 id="23-基于可用性的系统分类">2.3 基于可用性的系统分类</h3>

<p><img src="http://andy-blog.oss-cn-beijing.aliyuncs.com/blog/2020-07-21-WX20200721-214046%402x.png" width="60%" /></p>

<p>对于一个不具备容错性的系统，如果我们不采取任何措施来管理系统从崩溃中恢复或者保证在某些组件崩溃时数据仍然可用，那么该系统不可用的期望时间约为 37 年。而如果我们采取一些管理措施，那么这段时间将大大缩短。对于一个具备容错管理的系统，其期望宕机时间约为 1 小时。而对于可用性要求非常高的系统，其期望宕机时间仍然在 3 秒左右。根据不同系统的可用性和管理方式，可以将它们分为 7 个级别：完全无管理系统为 1 级，追求极端可用性系统为 7 级。</p>

<h3 id="24-影响系统可用性的因素">2.4 影响系统可用性的因素</h3>

<ul>
  <li>环境方面：诸如冷却、电源、天气、数据通信线路、火灾、地震、海啸、战争、人为破坏等</li>
  <li>操作方面：系统管理、系统配置和系统操作程序</li>
  <li>维护：定期维护的程序、定期更换硬件</li>
  <li>硬件：设备、冷却</li>
  <li>软件：程序</li>
  <li>流程：罢工、宕机管理决策</li>
  <li>内战</li>
</ul>

<h3 id="25-失效率">2.5 失效率</h3>

<p><strong>浴缸失效率曲线</strong></p>

<p><img src="http://andy-blog.oss-cn-beijing.aliyuncs.com/blog/2020-07-21-WX20200721-214708%402x.png" width="75%" /></p>

<p>上图展示了大部分系统所遵循的浴缸失效率曲线。假设现在有一个正在运行的系统，其初始的失效率将较高，因为在初始阶段，可能有些硬件会失效，而当我们替换掉这些失效的硬件时，随着运行时间增加，失效率将逐渐下降。然后，经过某个时间点后，随着系统运行时间进一步增加，由于硬件过热或者一些其他原因，失效率又会逐渐上升。</p>

<p><strong>失效频率 vs. 持续时间</strong></p>

<p><img src="http://andy-blog.oss-cn-beijing.aliyuncs.com/blog/2020-07-21-WX20200721-214911%402x.png" width="75%" /></p>

<p>如果我们绘制出失效次数和持续时间二者之间的关系，一些小的失效问题的持续时间较短，可能只需要 1 个小时就能恢复正常，这类事件发生次数通常较高；而某些失效的修复时间可能需要 10 个小时以上，这类失效的发生率通常较低。</p>

<h3 id="26-磁盘失效率">2.6 磁盘失效率</h3>

<p><img src="http://andy-blog.oss-cn-beijing.aliyuncs.com/blog/2020-07-22-WX20200722-135004%402x.png" width="70%" /></p>

<p>这里是一个磁盘失效率的例子。可以看到：软数据读取错误的 MTTF 约为 1 小时，无其他不良影响，恢复方式为重新尝试；可屏蔽的硬数据读取错误的 MTTF 约为 3 天，导致后果是重新映射到新的扇区，重写正确数据，恢复方式为 ECC (纠错编码)；而导致设备需要修复的错误类型的 MTTF 约为 5 年，导致的结果为数据不可用，恢复方式为磁盘维修。</p>

<h3 id="27-投票表决">2.7 投票表决</h3>

<p>现在，我们来看一个用于系统容错设计的基于多设备的简单策略：<strong>投票 (Voting)</strong>。</p>

<p>假设现在我们系统中有 3 台设备，这被称为 3-plex 系统 (如果有 $n$ 台设备即为 $n$-plex 系统)。如果其中一个磁盘上的数据发生错误，这 3 台设备将进行投票，其中 2 台上数据可以正常工作，那么根据 <strong>多数投票 (majority voting)</strong> 结果，即使某个设备发生数据错误，系统仍然能够正常运行。</p>

<p>根据多数投票的不同考虑方式，可以分为两类：<strong>Failvote (失败表决)</strong> 和 <strong>Failfast (失败即停)</strong>。</p>

<ul>
  <li><strong>Failvote</strong>：在 <strong>所有模块</strong> 上实行多数表决。
    <ul>
      <li>例如：对于三模块系统，多数意味着 $2/3$；对于五模块系统，多数意味着 $3/5$。</li>
    </ul>

    <p>Failvote 使用两个或多个模块并比较其输出。如果没有多数输出达成一致，则停止。尽管包含重复 (一对) 模块的失败次数是单模块失败次数的两倍，但其提供了清晰的失败语义。</p>

    <ul>
      <li>
        <p>通过三重化，系统的 MTTF 降至单个模块的为 $5/6 = 1/3 + 1/2 = 0.83$</p>

        <p>令 $M$ 为单个模块的 MTTF。三重化系统中的任意一个模块的 MTTF 均为 $M/3$，然后，两个工作模块中的任意一个模块的 MTTF 为 $M/2$。整个系统总的 MMTF 为：</p>

        <script type="math/tex; mode=display">M \times(1/3 + 1/2)= 0.83M</script>
      </li>
    </ul>
  </li>
  <li><strong>Failfast (voting)</strong>：此方案类似于 Failvote，区别在于 Failfast 系统会先检测哪些模块可用，然后在这些 <strong>可用模块</strong> 上实行多数表决。例如：</li>
</ul>

<p>– 10 plex Failfast系统将继续运行，直到9个模块发生故障为止；当5个模块出现故障时，Failvote将停止。</p>

<p>–故障转移系统比故障转移具有更好的可用性（因为在没有多数同意的情况下它会停止）。</p>

<p>下节内容：容错</p>
:ET