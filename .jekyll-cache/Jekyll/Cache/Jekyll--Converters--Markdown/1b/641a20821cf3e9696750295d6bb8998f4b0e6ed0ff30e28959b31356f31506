I"h3<h1 id="lecture-13-形式语言理论和有限状态自动机">Lecture 13 形式语言理论和有限状态自动机</h1>

<p>在接下来的两周，我们将学习 <strong>句法（syntax）</strong>相关内容。和目前为止我们学过的内容相比，这部分内容会比较偏理论。</p>

<h2 id="1-形式语言理论">1. 形式语言理论</h2>
<h3 id="11-什么是语言">1.1 什么是语言？</h3>
<p>目前为止，我们见过了一些处理单词、句子和文档等符号序列的方法：</p>
<ul>
  <li>语言模型</li>
  <li>隐马尔可夫模型</li>
  <li>循环神经网络</li>
</ul>

<p>但是，这些模型都没有涉及到语言的本质，因为它们可以用于处理任何符号序列，而不仅限于单词、句子等。</p>

<h3 id="12-形式语言理论">1.2 形式语言理论</h3>
<p><strong>形式语言理论 (Formal Language Theory)</strong> 为我们提供了一种定义语言的框架，它是一种数学框架。</p>

<p>在形式语言理论中：</p>
<ul>
  <li>一种语言 $=$ <strong>字符串 (strings)</strong> 的集合</li>
  <li>一个字符串 $=$ 来自一个有限 <strong>字母集 (alphabet)</strong> 的 <strong>元素 (element)</strong> 所组成的序列
    <ul>
      <li>字母集可以视为 <strong>词典 (vocabulary)</strong></li>
      <li>元素可以视为 <strong>单词 (words)</strong></li>
    </ul>
  </li>
</ul>

<h3 id="13-动机">1.3 动机</h3>
<p>形式语言理论研究的是语言的 <strong>类别 (classes)</strong> 和它们的计算特性。这门课中，我们将主要介绍以下两种形式语言：</p>
<ul>
  <li><strong>正则语言 (Regular Language)</strong></li>
  <li><strong>上下文无关语言 (Context Free Language)</strong></li>
</ul>

<p>这两种语言构成了形式语言理论中的前两个类别，之后还有更复杂的 <strong>上下文敏感语言 (Context Sensitive Language)</strong> 等，但是这门课中我们不会对其进行过多展开。</p>

<p>主要目的是为了解决 <strong>从属问题 (membership problem)</strong>：一个字符串是否属于某种语言。</p>

<p>那么，我们应该怎样做呢？我们可以定义该语言的 <strong>语法 (grammar)</strong>，然后检查该字符串是否符合该语法规则。</p>

<h3 id="14-例子">1.4 例子</h3>
<ul>
  <li>二进制串（Binary strings）以 0 开头，以 1 结尾
    <ul>
      <li><script type="math/tex">\{01, 001, 011, 0001, \dots\}</script> ⭕️</li>
      <li><script type="math/tex">\{1, 0, 00, 11, 100, \dots\}</script> ❌</li>
    </ul>
  </li>
  <li>来自字母集 <script type="math/tex">\{a, b\}</script> 的偶数长度的序列
    <ul>
      <li><script type="math/tex">\{aa, ab, ba, bb, aaaa, \dots\}</script> ⭕️</li>
      <li><script type="math/tex">\{aaa, aba, bbb, \dots\}</script> ❌</li>
    </ul>
  </li>
  <li>以 wh- 类型的单词作为开头，问号 ？结尾的英文句子
    <ul>
      <li><script type="math/tex">\{\textit{what }?, \textit{where my pants }?, \dots\}</script> ⭕️</li>
    </ul>
  </li>
</ul>

<h3 id="15-除了从属问题之外的问题">1.5 除了从属问题之外的问题</h3>
<ul>
  <li><strong>从属问题（Membership）</strong>
    <ul>
      <li>某个字符串是否属于某种语言？是/否</li>
    </ul>
  </li>
  <li><strong>评分（Scoring）</strong>
    <ul>
      <li>具有评分等级的从属关系</li>
      <li>某个字符串在多大程度上可以被接受？（语言模型）</li>
    </ul>
  </li>
  <li><strong>转导（Transduction）</strong>
    <ul>
      <li>将一个字符串转变为另一个字符串（词干提取 stemming）</li>
    </ul>
  </li>
</ul>

<h3 id="16-概览">1.6 概览</h3>
<p>本节课，我们主要涉及以下内容：</p>
<ul>
  <li><strong>正则语言（Regular languages）</strong></li>
  <li><strong>有限状态接收器 &amp; 转换器（Finite state acceptors &amp; transducers）</strong></li>
  <li><strong>单词形态学建模（Modelling word morphology）</strong></li>
</ul>

<h2 id="2-正则语言">2. 正则语言</h2>
<h3 id="21-正则语言">2.1 正则语言</h3>
<ul>
  <li><strong>正则语言（Regular language）</strong>：语言中最简单的类别。</li>
  <li>任何 <strong>正则表达式（regular expression）</strong>都是一种正则语言。
    <ul>
      <li>描述了什么样的字符串是该语言的一部分</li>
    </ul>
  </li>
  <li>正式地，一个正则表达式包含以下运算：
    <ul>
      <li>从字母集中抽样得到的符号：$\Sigma$</li>
      <li>空字符串：$\varepsilon$</li>
      <li>两个正则表达式的连接：$RS$</li>
      <li>两个正则表达式的交替：$R\mid S$</li>
      <li>星号表示出现 0 次或者重复多次：$R^*$</li>
      <li>圆括号定义运算的有效范围：$()$</li>
    </ul>
  </li>
</ul>

<h3 id="22-正则语言的例子">2.2 正则语言的例子</h3>
<ul>
  <li>二进制串（Binary strings）以 0 开头，以 1 结尾
    <ul>
      <li>$0 \,(0\mid 1)^* 1$</li>
    </ul>
  </li>
  <li>来自字母集 <script type="math/tex">\{a, b\}</script> 的偶数长度的序列
    <ul>
      <li>$((aa)\mid (ab)\mid (ba)\mid (bb))^*$</li>
    </ul>
  </li>
  <li>以 wh- 类型的单词作为开头，问号 ？结尾的英文句子
    <ul>
      <li>$((what)\mid (where)\mid (why)\mid (which)\mid (whose)\mid (whom))\Sigma^*?$</li>
    </ul>
  </li>
</ul>

<h3 id="23-正则语言的性质">2.3 正则语言的性质</h3>
<ul>
  <li><strong>封闭（Closure）</strong>：如果我们对正则语言 L1 和 L2 进行合并，得到的结果仍然是正则语言吗？如果是，那么我们将该运算称为 <strong>封闭运算（closed operation）</strong>。</li>
  <li>在以下运算中，正则语言是封闭的：
    <ul>
      <li><strong>连接（concatenation）</strong>和 <strong>求并（union）</strong>：来自封闭的定义。</li>
      <li><strong>求交（intersection）</strong>：在正则语言 L1 和 L2 中都合法的字符串。</li>
      <li><strong>求反（negation）</strong>：不在正则语言 L 中的字符串。</li>
    </ul>
  </li>
  <li>这种性质非常万金油，可以有不同的正则语言来描述语言的不同性质，然后将它们合并起来。
    <ul>
      <li>可以使用相同的核心算法来完成这些事。</li>
    </ul>
  </li>
</ul>

<h2 id="3-有限状态接收器">3. 有限状态接收器</h2>
<h3 id="31-有限状态接收器">3.1 有限状态接收器</h3>
<ul>
  <li>正则表达式定义了一个正则语言。</li>
  <li>但是，它并没有给出一种算法来检查某个字符串是否属于该语言。</li>
  <li><strong>有限状态接收器（Finite state acceptors，FSA）</strong>给出了检查某个成员（字符串）是否属于某个正则语言的算法。</li>
  <li>FSA 包含：
    <ul>
      <li>输入符号的字母集：$\Sigma$</li>
      <li>状态集合：$Q$</li>
      <li>起始状态：$q_0\in Q$</li>
      <li>最终状态：$F\subseteq Q$</li>
      <li>转移函数：符号和状态 $\to$ 下一个状态</li>
    </ul>
  </li>
  <li>如果存在一条从 $q_0$ 到最终状态的 <strong>路径（path）</strong>，并且转移函数与路径上的每个符号都匹配，则接受该字符串。
    <ul>
      <li>Djisktra 最短路径算法，$O(V\log V +E)$</li>
    </ul>
  </li>
</ul>

<h3 id="32-fsa-的例子">3.2 FSA 的例子</h3>
<ul>
  <li>输入字母集：<script type="math/tex">\{a,b\}</script></li>
  <li>状态：<script type="math/tex">\{q_0,q_1\}</script></li>
  <li>起始状态：$q_0$</li>
  <li>最终状态：<script type="math/tex">\{q_1\}</script></li>
  <li>转移函数：<script type="math/tex">\{(q_0,a) \to q_0, \;(q_0,b) \to q_1, \;(q_1,b) \to q_1\}</script></li>
  <li>注意：如果在 $q_1$ 状态下应用 $a$ 符号会导致失败。</li>
  <li>接受 $a^*bb^*$</li>
</ul>

<p><img src="http://andy-blog.oss-cn-beijing.aliyuncs.com/blog/2020-07-09-WX20200709-165320%402x.png" width="40%" /></p>

<h3 id="33-派生形态">3.3 派生形态</h3>
<p>使用词缀（affixes）将一个单词变为另外一种语法类别：</p>
<ul>
  <li>$\textit{grace} \to \textit{graceful} \to \textit{gracefully}$</li>
  <li>$\textit{grace} \to \textit{disgrace} \to \textit{disgracefully}$</li>
  <li>$\textit{allure} \to \textit{alluring} \to \textit{alluringly}$</li>
  <li>$\textit{allure} \to *\textit{allureful}$</li>
  <li>$\textit{allure} \to *\textit{disallure}$</li>
</ul>

<p>注：$*$ 表示无效派生</p>

<h3 id="34-fsa-用于单词形态学">3.4 FSA 用于单词形态学</h3>

<p>为什么 FSA 可以用于单词形态学？</p>

<p>因为可以看到，FSA（几乎）具有一致的处理流程。那么，我们可以将其描述为一种正则语言吗？</p>
<ul>
  <li>希望接受有效形式，拒绝无效形式（带 $*$ 标记）</li>
  <li>泛化到其他单词，例如：表现类似 $\textit{grace}$ 或者 $\textit{allure}$ 的名词</li>
</ul>

<p>下面是一个 FSA 用于单词形态学的例子：</p>

<p><img src="http://andy-blog.oss-cn-beijing.aliyuncs.com/blog/2020-07-09-WX20200709-230156%402x.png" /></p>

<p>我们可以将上图进行一些压缩处理，合并一些具有共同路径的分支：</p>

<p><img src="http://andy-blog.oss-cn-beijing.aliyuncs.com/blog/2020-07-09-WX20200709-230915%402x.png" /></p>

<p>我们还可以加入更多的单词，并对其中具备相似性质的单词进行合并，当我们构建了这样一个非常复杂的 FSA 之后，我们就可以检查某个单词是否可以派生出一些其他合法的形态。</p>

<h2 id="4-加权-fsa">4. 加权 FSA</h2>
<h3 id="41-加权-fsa">4.1 加权 FSA</h3>
<p>我们已经介绍了 FSA 作为一种从属问题的二分类检测器，即某个单词是否可以添加相应的词缀来生成新的合法单词。但是，有时我们希望这个过程可以具有更多的评分性质，不仅仅是单纯的非此即彼的二分类问题。</p>

<ul>
  <li>有些单词比其他单词更有可能被接受：
    <ul>
      <li>$\textit{fishful}$ vs. $\textit{disgracelyful}$<br />
虽然二者都不是合法的英文单词，但是，从某种程度上，我们可以认为 $\textit{fishful}$ 要比 $\textit{disgracelyful}$ 更有可能作为一个合法英文单词，因为其从字面上更容易理解一些。</li>
      <li>$\textit{musicky}$ vs. $\textit{writey}$<br />
同理，$\textit{musicky}$ 要比 $\textit{writey}$ 更有可能成为一个形容词。所以，有些单词作为合法单词的可能性要高于其他一些单词，语言和单词并不仅仅是二元类别的。</li>
    </ul>
  </li>
  <li>关于可接受程度的评分方式 —— <strong>加权 FSA</strong>：
    <ul>
      <li>状态集合：$Q$</li>
      <li>输入符号的字母集：$\Sigma$</li>
      <li>起始状态加权函数：$\lambda: Q \to \mathbb R$</li>
      <li>最终状态加权函数：$\rho: Q \to \mathbb R$</li>
      <li>转移函数：$\delta: (Q,\Sigma, Q) \to \mathbb R$</li>
    </ul>
  </li>
</ul>

<h3 id="42-wfsa-最短路径">4.2 WFSA 最短路径</h3>
<p>对于路径 $\pi=t_1,\dots, t_N$，现在其总分为：</p>

<script type="math/tex; mode=display">\lambda(t_0)+\sum_{i=1}^{N}\delta(t_i)+\rho(t_N)</script>

<p>其中，每个 $t$ 都是一条边，因此在分数计算中，更正式的方式是使用转移前后的状态和边的标签。</p>

<p>利用 <strong>最短路径算法</strong> 来找到具有最小代价的路径 $\pi$，计算复杂度和之前一样，为 $O(V\log V+E)$。</p>

<h3 id="43-n-gram-语言模型作为-wfsa">4.3 N-gram 语言模型作为 WFSA</h3>
<p>这里，我们使用 n-gram 语言模型作为一个例子，来看一下如何利用 WFSA 来衡量 n-gram 概率。</p>

<p>回忆一下，在 n-gram 语言模型中， 我们采用如下方式对字符串（句子）进行评分：</p>

<script type="math/tex; mode=display">P(w_1,\dots,w_M)\approx \prod_{m=1}^{M}P_n(w_m\mid w_{m-1},\dots,w_{m-n+1})</script>

<p>现在，我们用 FSA 表示 Unigram 语言模型：</p>
<ul>
  <li>一个状态：$q_0$</li>
  <li>状态转移得分：$\delta(q_0,w,q_0)=\log P_1(w)$</li>
  <li>初始状态和最终状态得分 $=0$</li>
  <li>
    <p>序列 $w_1, w_2, \dots, w_M$ 的路径得分为：</p>

    <script type="math/tex; mode=display">0+\sum_{m}^{M}\delta(q_0,w_m,q_0)+0=\sum_{m}^{M}\log P_1(w_m)</script>
  </li>
</ul>

<p>现在，让我们再来看一下 Bigram 语言模型：</p>

<script type="math/tex; mode=display">P(w_1,w_2,\dots,w_M)=\prod_{i=1}^{M}P(w_i\mid w_{i-1})</script>

<p>Bigram 语言模型的 WFSA 实现：</p>
<ul>
  <li>输入符号的字母集：$\Sigma=$ 单词 types 的集合（即词汇表 vocabulary）</li>
  <li>状态集合 $Q=\Sigma$（状态数量 $=$ 单词 types 的数量）<br />
因为现在我们是在 Bigram 语言模型下，我们需要一个状态来记住当前单词的前一个上下文单词。</li>
</ul>

<h2 id="6-扩展阅读">6. 扩展阅读</h2>

<ul>
  <li>E18, Ch 16</li>
</ul>

<p>下节内容：形式语言理论和有限状态自动机</p>

:ET